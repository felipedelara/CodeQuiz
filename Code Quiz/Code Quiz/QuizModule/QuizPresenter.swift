//
//  QuizPresenter.swift
//  Code Quiz
//
//  Created by Felipe on 02/09/19.
//  Copyright (c) 2019 Felipe de Lara. All rights reserved.
//
//  This file was generated by the ðŸ VIPER generator
//

import UIKit

final class QuizPresenter {

    // MARK: - Private properties -

    private unowned let view: QuizViewInterface
    private let interactor: QuizInteractorInterface
    private let wireframe: QuizWireframeInterface

    
    var keywords : [String] = []
    
    var correctAnswers = [String](){
        willSet {
            view.setScore(score: "\(newValue.count)/\(keywords.count)")
            view.setTable(tableData: newValue)
        }
    }

    var gameState = GameState.initial {
        willSet {
            self.view.updateGame(toFitState: newValue)
        }
    }
    
    var timeCounter = 3 {
        willSet {
            let (_, min, sec) = TimeFormat.secondsToHoursMinutesSeconds(seconds: newValue)
            self.view.setCounter(time: "\(String(format: "%02d", min)):\(String(format: "%02d", sec))")
        }
    }
    
    var timer = Timer()
    
    // MARK: - Lifecycle -

    init(view: QuizViewInterface, interactor: QuizInteractorInterface, wireframe: QuizWireframeInterface) {
        self.view = view
        self.interactor = interactor
        self.wireframe = wireframe
    }
}

// MARK: - Extensions -

extension QuizPresenter: QuizPresenterInterface {

    
    func notifyViewDidLoad() {
        print("Presenters is aware that view finished loaded")
        view.setupInitialView()

        view.showLoading()
        interactor.fetchCorrectKeywords(){ [weak self] success, keywords in
            self?.view.hideLoading()
            
            guard let answers = keywords?.answer, let question = keywords?.question else{
                //error
                return
            }
            self?.keywords = answers
            self?.view.setTitle(text: question)
            //update interface
        }
    }
    
    func notifyViewDidAppear() {
        print("Presenters is aware that view finished appearing")
    }
    
    func mainButtonPressed() {
        switch self.gameState {
        case .initial:
            self.gameState = .ongoing
            precondition(self.correctAnswers.isEmpty)
            self.startTimer()
        default:
            //handle
            self.timer.invalidate()
            self.timeCounter = 300
            self.correctAnswers.removeAll()
            self.gameState = .initial
        }
    }
    
    func keyworkdsTextViewDidChange(text: String) {
        if self.gameState != .ongoing{
            self.gameState = .ongoing
            self.startTimer()
        }
        
        for keyword in self.keywords{
            if text.uppercased() == keyword.uppercased(){
                var keyworkAlreadyExists = false
                
                for answer in correctAnswers{
                    if text == answer{
                        keyworkAlreadyExists = true
                    }
                }
                
                if !keyworkAlreadyExists{
                    handleGotKeywordRight(keyword)
                }
            }
        }
    }
    
    func handleGotKeywordRight(_ keyword: String) {
        self.correctAnswers.append(keyword.uppercased())
        view.setScore(score: "\(correctAnswers.count)/\(keywords.count)")
        view.clearTextField()
        self.checkVictory()
    }
    
    func checkVictory(){
        if self.keywords.count == self.correctAnswers.count{
            view.showVictory()
            self.timer.invalidate()
            self.gameState = .victory
        }
    }
    
    func keywordsFetchSuccess(keywords: Keywords) {
        //todo update viewmodel
        print("Presenters got keywords from interactor")
        view.hideLoading()
    }
    
    func keywordsFetchFailed(with errorMessage: String) {
        //todo update viewmodel
        print("Presenters failed getting keywords from interactor")
//        view.hideLoading()
    }
 
    //MARK: - Timer
    func startTimer(){
        self.timer = Timer.scheduledTimer(timeInterval: 1.0, target: self, selector: #selector(updateCounter), userInfo: nil, repeats: true)
    }
    
    @objc func updateCounter() {
        if timeCounter > 0 {
            //Timer still valid
            timeCounter -= 1
        } else{
            //Game over
            self.timer.invalidate()
            self.gameState = .defeat
        }
    }
}
